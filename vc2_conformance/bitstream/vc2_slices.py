r"""
:py:class:`BitstreamValue`\ s for representing series of coded picture slices.

The vast majority of a VC-2 bitstream is made up of sequences of 'slices'
(13.5.2). Unfortunately, while it is possible to describe slices by combining
the various :py:class:`BitstreamValue` subclasses, doing so requires extremely
large numbers of Python objects to be created (several per picture pixel). Even
for low resolution pictures, the runtime overhead of instantiating all of these
objects amounts to many seconds, growing to minutes for large pictures.

To achieve useful runtime performance an alternative, less declarative,
implementation of a slice serialisation/deserialisation is used.
"""

from vc2_conformance.math import intlog2

from vc2_conformance.bitstream import (
    BoundedReader,
    BoundedWriter,
    BitstreamValue,
    ConstantValue,
    FunctionValue,
    ensure_bitstream_value,
    SubbandArray,
)

from vc2_conformance.bitstream.formatters import Hex, Bin

from vc2_conformance.bitstream._util import (
    indent,
    ellipsise,
    concat_tabular_strings,
)

from vc2_conformance.bitstream._integer_io import (
    signed_exp_golomb_length,
)

from vc2_conformance.bitstream._fsm_io import (
    Token,
    TokenTypes,
    read_fsm,
    write_fsm,
)

__all__ = [
    "LDSliceArray",
    "HQSliceArray",
]


def resize_list(lst, new_length, new_value_constructor=lambda: 0):
    """
    Given a list, resize it to be new_length entries long. Excess values will
    be silently discarded, extra values will be generated by calling
    new_value_constructor with no arguments.
    """
    assert new_length < 1024*1024*1024
    if len(lst) > new_length:
        del lst[new_length:]
    elif len(lst) < new_length:
        lst.extend(
            new_value_constructor()
            for _ in range(new_length - len(lst))
        )

def subband_dimensions(w, h, dwt_depth, dwt_depth_ho, level):
    """
    Compute the width and height of a component subband as defined by
    (13.2.3) subband_width() and subband_height().
    
    Parameters
    ==========
    w, h : int
        The picture component dimensions
    dwt_depth, dwt_depth_ho : int
        The wavelet transform depths (2D and horizontal only)
    level : int
        The transform level to compute this value for
    """
    scale_w = 1 << (dwt_depth_ho + dwt_depth)
    scale_h = 1 << dwt_depth
    
    pw = scale_w * ( (w+scale_w-1) // scale_w)
    ph = scale_h * ( (h+scale_h-1) // scale_h)
    
    if level == 0:
        subband_width = pw // (1 << (dwt_depth_ho + dwt_depth))
    else:
        subband_width = pw // (1 << (dwt_depth_ho + dwt_depth - level + 1))
    
    if level <= dwt_depth_ho:
        subband_height = ph // (1 << dwt_depth)
    else:
        subband_height = ph // (1 << (dwt_depth_ho + dwt_depth - level + 1))
    
    return (subband_width, subband_height)

    
def slice_subband_bounds(sx, sy, subband_width, subband_height, slices_x, slices_y):
    """(13.5.6.2) Compute the (x1, y1, x2, y2) of a slice subband."""
    return (
        (subband_width * sx) // slices_x,
        (subband_height * sy) // slices_y,
        (subband_width * (sx + 1)) // slices_x,
        (subband_height * (sy + 1)) // slices_y,
    )

def to_coeff_index(subband_widths, subband_heights,
                   slices_x, slices_y,
                   sx, sy,
                   subband_index=0,
                   x=0, y=0):
    """
    Compute the index of the start of a slice's data in a 1D array which stores
    a whole picture's worth of a single component's transform coefficients in
    bitstream order. This is conceptually equivalent to an array with the
    following indices::
    
        component_coeffs[sy][sx][subband_index][y][x]
    
    Where 'sy' and 'sx' are slice coordinates and 'subband_index' is an index
    according to the indexing scheme defined by SubbandArray (and the VC-2
    specification), and 'y' and 'x' are coordinates within the slice and
    subband selected.
    
    Throws an IndexError if any value with the exception of slices_y is out of
    range. This singular exception is allowed to accomodate situations where a
    bitstream (invalidly) contains slices past the end of the picture.
    """
    if not (0 <= sx < slices_x):
        raise IndexError("slice x-coordinate out of range")
    
    # NB: Explicitly *don't* check range of 'sy'
    
    if not (0 <= subband_index < len(subband_widths)):
        raise IndexError("subband index out of range")
    
    offset = 0
    
    # The width/height of the target subband in this slice
    subband_slice_width = None
    subband_slice_height = None
    
    # Offset to current slice and subband (and while we're at it, get the
    # subband slice width/height)
    for cur_subband_index, (subband_width, subband_height) in enumerate(
            zip(subband_widths, subband_heights)):
        x1, y1, x2, y2 = slice_subband_bounds(
            sx, sy,
            subband_width, subband_height,
            slices_x, slices_y
        )
        # Say we're in slice sx=3, sy=2, then the slice out of the current
        # subband will look like:
        #
        #     +---+---+---+---+---+---+
        #     |   |   |   |   |   |   |
        #     +---+---+---+---+---+---+
        #     |   |   |   |   |   |   |
        #     +---+---+---+---+---+---+
        #     |   |   |   |3,2|   |   |
        #     +---+---+---+---+ - + - +
        #     |   |   |   |   |   |   |
        #     +---+---+---+---+---+---+
        #     |   |   |   |   |   |   |
        #     +---+---+---+---+---+---+
        #
        # The offset beforehand, therefore is
        #
        #              |<--- subband_width --->|
        #              |                       |
        #
        #              +-----------------------+  ------------
        #              |#######################|   A        A
        #              |#######################|   | y1     |
        #              |#######################|   V        |
        #         -+-  +-----------+---+---+---+  ---       |
        #    y2-y1 |   |@@@@@@@@@@@|3,2'   '   '            subband_height
        #         -+-  +---+---+---+ - + - + - +            |
        #              '   '   '   '   '   '   '            |
        #              + - + - + - + - + - + - +            |
        #              '   '   '   '   '   '   '            V
        #              + - + - + - + - + - + - +  ------------
        #
        #              |           |
        #              |<--- x1 -->|
        #
        # Which consists of all of the slices above the current slice:
        #
        #    area '#' = subband_width * y1
        #
        # Plus all of the area to the left of the slice in the same row
        #
        #    area '@' = x1 * (y2 - y1)
        #
        # Using the above we get the offset to the top-left corner of the
        # current subband slice as:
        #
        #     (subband_width * y1) + (x1 * (y2 - y1))
        #
        # Likewise, the next offset after the bottom-right corner of the
        # current subband slice will be
        #
        #     (subband_width * y1) + (x2 * (y2 - y1))
        if cur_subband_index >= subband_index:
            offset += (y1 * subband_width) + (x1 * (y2 - y1))
        else:
            offset += (y1 * subband_width) + (x2 * (y2 - y1))
        
        if cur_subband_index == subband_index:
            subband_slice_width = x2 - x1
            subband_slice_height = y2 - y1
    
    # NB: When large numbers of slices and/or transform levels are used, some
    # subbands may have zero width/height in some slices.
    if not (subband_slice_width == x == 0 or 0 <= x < subband_slice_width):
        raise IndexError("slice value x-coordinate index out of range")
    if not (subband_slice_height == y == 0 or 0 <= y < subband_slice_height):
        raise IndexError("slice value y-coordinate index out of range")
    
    # Offset to required coordinate within selected slice and subband
    offset += (y * subband_slice_width) + x
    
    return offset


class BaseSliceArray(BitstreamValue):
    """
    An array of consecutive coded picture slices as per transform_data()
    (13.5.2) and fragment_data() (14.4).
    """
    
    def __init__(self,
                 sequence_header,
                 transform_parameters,
                 start_sx=None,
                 start_sy=None,
                 slice_count=None):
        """
        Parameters
        ==========
        sequence_header : :py:class:`SequenceHeader`
            The sequence header for the sequence these slices are part of.
        transform_parameters : :py:class:`TransformParameters`
            The transform parameters for the picture these slices are part of.
        start_sx, start_sy : int or :py:class:`BitstreamValue` or None
            By default, this slice array will be sized to include every slice
            in the picture. If these arguments are not None, they should
            specify the slice coordinates of the first slice in the array. The
            ``slice_count`` argument must also be given.
        slice_count : int or :py:class:`BitstreamValue` or None
            When ``start_sx`` and ``start_sy`` is provided, this argument
            indicates the number of slices to include in the array. Slices will
            be included in raster-scan order (as defined by (14.4)
            fragment_data()). If ``start_sx`` and ``start_sy`` are omitted,
            this argument must also be omitted.
        """
        super(BaseSliceArray, self).__init__()
        
        # Store arguments
        assert (start_sx is None) is (start_sy is None) is (slice_count is None), (
            "Either all or none of start_sx, start_sx and slice_count must be given"
        )
        self._sequence_header = sequence_header
        self._transform_parameters = transform_parameters
        if start_sx is None:
            start_sx = ConstantValue(0)
            start_sy = ConstantValue(0)
            slice_count = FunctionValue(
                BaseSliceArray._compute_picture_slice_count,
                transform_parameters,
            )
        self._start_sx_bitstream_value = ensure_bitstream_value(start_sx)
        self._start_sy_bitstream_value = ensure_bitstream_value(start_sy)
        self._slice_count_bitstream_value = ensure_bitstream_value(slice_count)
        
        # Setup change notifications
        self._sequence_header._notify_on_change(self)
        self._transform_parameters._notify_on_change(self)
        self._start_sx_bitstream_value._notify_on_change(self)
        self._start_sy_bitstream_value._notify_on_change(self)
        self._slice_count_bitstream_value._notify_on_change(self)
        
        self._transform_parameters.dwt_depth._notify_on_change(self)
        self._transform_parameters.dwt_depth_ho._notify_on_change(self)
        
        self._sequence_header.luma_dimensions._notify_on_change(self)
        self._sequence_header.color_diff_dimensions._notify_on_change(self)
        
        # A number of metrics are computed based on the above parameters which
        # are then widely used within the class. These metrics are updated
        # whenever the above change by a call to _update_metrics. (This is then
        # followed by a call to _resize which resizes the internal data
        # structures according to the updated metrics.)
        
        # The number of slices a picture is divided into (12.4.5.2)
        self._slices_x = None
        self._slices_y = None
        
        # The coordinates of the top-left slice (from
        # self._start_sx_bitstream_value and self._start_sy_bitstream_value)
        self._start_sx = None
        self._start_sy = None
        
        # The number of consecutive raster-scan-order slices in this array
        # (from self._slice_count_bitstream_value)
        self._slice_count = None
        
        # The number of wavelet transform levels used in 2D and horizontally
        # (12.4.1) and (12.4.4.1).
        self._dwt_depth = None
        self._dwt_depth_ho = None
        
        # The full dimensions of the luminance and color-difference picture
        # components (11.6.2)
        self._luma_width = None
        self._luma_height = None
        self._color_diff_width = None
        self._color_diff_height = None
        
        # The dimensions of each wavelet transform subband for luminance and
        # color-difference picture components (13.2.3).
        #
        # Stored as tuples of values indexed by subband index (i.e. with three
        # subbands per level for 2D transforms and 1 per level otherwise)
        self._luma_subband_widths = None
        self._luma_subband_heights = None
        self._color_diff_subband_widths = None
        self._color_diff_subband_heights = None
        
        # The offset of indices of _y_coeffs and _c1_coeffs/_c2_coeffs,
        # respectively, which is must be subtracted from indices produced by
        # to_coeff_index to produce valid list indices.
        self._luma_coeffs_index_offset = None
        self._color_diff_coeffs_index_offset = None
        
        # Picture slices contain the following:
        #
        # * A slice of the transform coefficients, grouped by picture component
        #   and transform subband.
        # * Prefix (padding) bytes (high-quality pictures only)
        # * A quantisation index
        # * Length indicators describing the number of bits in the bitstream
        #   allocated to storing each picture component (A.4.2).
        #
        # The exact layout varies between high-quality and low-delay slices but
        # the general principle is the same. The total number of transform
        # coefficients, parameters and padding values can be worked out from
        # the information in the SequenceHeader and TransformParameters.
        # Because of this, memory can be allocated in advance.
        #
        # Because instantiating large numbers of Python objects is extremely
        # slow, all parameters are stored in a series of flat lists.
        #
        # The API implemented by this class provides external users with a more
        # structured way to perform random access to the underlying lists.
        #
        # Whenever one of the input parameters changes, the internal
        # data-structures will be resized accordingly.
        
        # The quantisation index associated with each slice. A list of integers
        # in raster-scan order.
        self._qindex = []
        
        # (other per-slice fields should be added in subclasses)
        
        # Transform data will be kept in three flat lists below -- one for each
        # component. Within each list the transform components will be arranged
        # in bitstream order, that is (loosely) the following indexing:
        #
        #    component_coeffs[sy][sx][subband_index][y][x]
        #
        # (See to_coeff_index()). The list will be offset such that _start_sx,
        # _start_sy are at list index 0.
        self._y_coeffs = []
        self._c1_coeffs = []
        self._c2_coeffs = []
        
        # Trigger the initial population of metrics/data structures
        self._dependency_changed(None)
    
    def _dependency_changed(self, _):
        self._update_metrics()
        self._resize()
        
        self._changed()
    
    def _update_metrics(self):
        """
        This routine recomputes the various internal slice metrics computed
        from the :py:class:`SliceParameters` and
        :py:class:`TransformParameters`.
        """
        # NB: Internally, values are clamped to sensible values to prevent
        # crashes in the presence of invalid data.
        
        slice_parameters = self._transform_parameters["slice_parameters"]
        self._slices_x = max(1, slice_parameters["slices_x"].value)
        self._slices_y = max(1, slice_parameters["slices_y"].value)
        
        self._start_sx = min(self._slices_x-1, max(0, self._start_sx_bitstream_value.value))
        self._start_sy = min(self._slices_y-1, max(0, self._start_sy_bitstream_value.value))
        
        self._slice_count = max(1, self._slice_count_bitstream_value.value)
        
        self._dwt_depth = max(0, self._transform_parameters.dwt_depth.value)
        self._dwt_depth_ho = max(0, self._transform_parameters.dwt_depth_ho.value)
        
        self._luma_width, self._luma_height = \
            self._sequence_header.luma_dimensions.value
        self._color_diff_width, self._color_diff_height = \
            self._sequence_header.color_diff_dimensions.value
        
        self._luma_width = max(1, self._luma_width)
        self._luma_height = max(1, self._luma_height)
        self._color_diff_width = max(1, self._color_diff_width)
        self._color_diff_height = max(1, self._color_diff_height)
        
        self._luma_subband_widths, self._luma_subband_heights = zip(*(
            subband_dimensions(
                w=self._luma_width,
                h=self._luma_height,
                dwt_depth=self._dwt_depth,
                dwt_depth_ho=self._dwt_depth_ho,
                level=level,
            )
            for level in range(self._num_subband_levels)
            for _ in range(1 if level < (1 + self._dwt_depth_ho) else 3)
        ))
        
        self._color_diff_subband_widths, self._color_diff_subband_heights = zip(*(
            subband_dimensions(
                w=self._color_diff_width,
                h=self._color_diff_height,
                dwt_depth=self._dwt_depth,
                dwt_depth_ho=self._dwt_depth_ho,
                level=level,
            )
            for level in range(self._num_subband_levels)
            for _ in range(1 if level < (1 + self._dwt_depth_ho) else 3)
        ))
        
        # NB: These may be out-of-range if an input is also out of range.
        try:
            self._luma_coeffs_index_offset = to_coeff_index(
                self._luma_subband_widths,
                self._luma_subband_heights,
                self._slices_x,
                self._slices_y,
                self._start_sx,
                self._start_sy,
            )
        except:
            self._luma_coeffs_index_offset = 0
        try:
            self._color_diff_coeffs_index_offset = to_coeff_index(
                self._color_diff_subband_widths,
                self._color_diff_subband_heights,
                self._slices_x,
                self._slices_y,
                self._start_sx,
                self._start_sy,
            )
        except:
            self._color_diff_coeffs_index_offset = 0
    
    def _resize(self):
        """
        Resize internal data structures following a possible change in metrics
        or slice position.
        """
        resize_list(self._qindex, self._slice_count)
        
        # Determine lengths of luma/chroma coefficient lists
        start_slice_index = self._start_sx + (self._start_sy * self._slices_x)
        end_slice_index = start_slice_index + self._slice_count
        
        end_sx = end_slice_index % self._slices_x
        end_sy = end_slice_index // self._slices_x
        
        num_luma_coeffs = self._to_luma_coeff_index(end_sx, end_sy)
        num_color_diff_coeffs = self._to_color_diff_coeff_index(end_sx, end_sy)
        
        resize_list(self._y_coeffs, num_luma_coeffs)
        resize_list(self._c1_coeffs, num_color_diff_coeffs)
        resize_list(self._c2_coeffs, num_color_diff_coeffs)
    
    def _to_slice_index(self, sx, sy):
        """
        Convert a slice coordinate into a slice index relative to the slices in
        this array (i.e. (:py:attr:`_start_sx`, :py:attr:`_start_sy`) has index
        0).
        """
        index = sx + (sy * self._slices_x)
        
        offset = self._start_sx + (self._start_sy * self._slices_x)
        index -= offset
        
        return index
    
    def _from_slice_index(self, slice_index):
        """
        Convert from a slice index to (sx, sy) tuple (where 0 is
        (:py:attr:`_start_sx`, :py:attr:`_start_sy`)).
        """
        offset = self._start_sx + (self._start_sy * self._slices_x)
        slice_index += offset
        
        x = slice_index % self._slices_x
        y = slice_index // self._slices_x
        
        return (x, y)
    
    def _to_luma_coeff_index(self, sx, sy, subband_index=0, x=0, y=0):
        """
        Convert from a slice coordinate, subband and coefficient coordinate
        into an index into :py:attr:`_y_coeffs`.
        """
        return to_coeff_index(
            self._luma_subband_widths,
            self._luma_subband_heights,
            self._slices_x,
            self._slices_y,
            sx, sy,
            subband_index,
            x, y
        ) - self._luma_coeffs_index_offset
    
    def _to_color_diff_coeff_index(self, sx, sy, subband_index=0, x=0, y=0):
        """
        Convert from a slice coordinate, subband and coefficient coordinate
        into an index into :py:attr:`_c1_coeffs` or :py:attr:`_c2_coeffs`.
        """
        return to_coeff_index(
            self._color_diff_subband_widths,
            self._color_diff_subband_heights,
            self._slices_x,
            self._slices_y,
            sx, sy,
            subband_index,
            x, y
        ) - self._color_diff_coeffs_index_offset
    
    @property
    def _num_subband_levels(self):
        """The number of subband levels."""
        return 1 + self._dwt_depth_ho + self._dwt_depth
    
    @property
    def _num_subbands(self):
        """The total number of subbands."""
        return 1 + self._dwt_depth_ho + (self._dwt_depth * 3)
    
    @staticmethod
    def _compute_picture_slice_count(transform_parameters):
        """
        Given a :py:class:`TransformParameters`, return the total number of
        slices in a picture.
        """
        slice_parameters = transform_parameters["slice_parameters"]
        return (
            slice_parameters["slices_x"].value *
            slice_parameters["slices_y"].value
        )
    
    def _iter_slice_indices_and_coords(self):
        """
        An iterator over (slice_index, sx, sy) tuples for this slice array.
        
        Slice indices will start from 0 (for slice :py:attr:`_start_sx`,
        :py:attr:`_start_sy`).
        
        The slice coordinates will be global slice coordinates.
        """
        slice_index_offset = self._start_sx + (self._start_sy * self._slices_x)
        for slice_index in range(self._slice_count):
            sx = (slice_index_offset + slice_index) % self._slices_x
            sy = (slice_index_offset + slice_index) // self._slices_x
            
            yield (slice_index, sx, sy)
    
    def _get_slice_num_component_coefficients(self, sx, sy):
        """
        Returns the number of luminance and color-difference coefficients
        contained in the specified slice.
        """
        num_luma_coeffs = 0
        for subband_width, subband_height in zip(self._luma_subband_widths,
                                                 self._luma_subband_heights):
            x1, y1, x2, y2 = slice_subband_bounds(
                sx, sy,
                subband_width, subband_height,
                self._slices_x, self._slices_y,
            )
            num_luma_coeffs += (x2 - x1) * (y2 - y1)
        
        num_color_diff_coeffs = 0
        for subband_width, subband_height in zip(self._color_diff_subband_widths,
                                                 self._color_diff_subband_heights):
            x1, y1, x2, y2 = slice_subband_bounds(
                sx, sy,
                subband_width, subband_height,
                self._slices_x, self._slices_y,
            )
            num_color_diff_coeffs += (x2 - x1) * (y2 - y1)
        
        return num_luma_coeffs, num_color_diff_coeffs
    
    def _get_view(self, sx, sy):
        """
        Return a suitable :py:class:`BaseSliceView` of a slice in this array.
        Intended for overriding by subclasses to produce specialised views of
        this class.
        """
        return BaseSliceView(self, sx, sy)
    
    def __getitem__(self, key):
        """
        Access a :py:class:`BaseSliceView` of the data contained in one of the
        slices in this :py:class:`BaseSliceArray`.
        
        Supports either of the following indexing styles:
        
        * ``a[slice_index]`` (where '0' is the first slice in the array)
        * ``a[sx, sy]``
        """
        if isinstance(key, tuple):
            sx, sy = key
            return self._get_view(sx, sy)
        else:
            return self._get_view(*self._from_slice_index(key))
    
    def __iter__(self):
        """
        Iterate over the slices in this :py;class:`BaseSliceArray`.
        """
        for sx, sy, view in self.items():
            yield view
    
    def items(self):
        """
        Iterator producing (sx, sy, slice_view) tuples for every slice in the
        array.
        """
        for slice_index in range(self._slice_count):
            sx, sy = self._from_slice_index(slice_index)
            yield (sx, sy, self._get_view(sx, sy))
    
    def __repr__(self):
        return "<{} start_sx={} start_sy={} slice_count={}>".format(
            self.__class__.__name__,
            self._start_sx,
            self._start_sy,
            self._slice_count,
        )
    
    def __str__(self):
        return repr(self)


class BaseSliceView(object):
    """
    A view for accessing the values of a single slice in a
    :py:class:`BaseSliceArray`.
    """
    
    def __init__(self, slice_array, sx, sy):
        self._slice_array = slice_array
        self._sx = sx
        self._sy = sy
    
    @property
    def sx(self):
        return self._sx
    
    @property
    def sy(self):
        return self._sy
    
    @property
    def slice_index(self):
        return self._slice_array._to_slice_index(self._sx, self._sy)
    
    @property
    def qindex(self):
        return self._slice_array._qindex[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @qindex.setter
    def qindex(self, value):
        self._slice_array._qindex[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def y_coeffs(self):
        return ComponentView(self._slice_array, "y", self._sx, self._sy)
    
    @property
    def c1_coeffs(self):
        return ComponentView(self._slice_array, "c1", self._sx, self._sy)
    
    @property
    def c2_coeffs(self):
        return ComponentView(self._slice_array, "c2", self._sx, self._sy)
    
    def __repr__(self):
        return "<{} sx={} sy={}>".format(
            self.__class__.__name__,
            self._sx,
            self._sy,
        )

def component_views_str(block_length, block_padding, *component_views):
    r"""
    Generate a string representation of a set of interleaved
    :py:class:`ComponentView`\ s. For use as a basis for producing string
    representations of slice views.
    
    Parameters
    ==========
    block_length : int
        The length of the bounded block these component values reside in
    block_padding : int
        The padding value for any unused bits in the block.
    component_views : :py:class:`ComponentView`
        The components whose coefficients are interleaved. If multiple
        views are provided, these must have exactly the same number of
        subbands and have the same subband dimensions.
    """
    out = []
    
    # Create table of coefficients
    bits_remaining = block_length
    for component_subband_views in zip(*component_views):
        w, h = component_subband_views[0].dimensions
        
        # Skip slices without any coefficients
        if w*h == 0:
            continue
        
        level, subband = component_subband_views[0].subband
        out.append("Level {}, {}:".format(level, subband))
        
        table = [[None]*w for _ in range(h)]
        for i, values in enumerate(zip(*component_subband_views)):
            # Add a '*' to any values past the end of the bounded block
            strings = []
            for value in values:
                bits_remaining -= signed_exp_golomb_length(value)
                if bits_remaining >= 0:
                    strings.append(str(value))
                else:
                    strings.append("{}*".format(value))
            
            # Combine the values into a single string
            if len(strings) == 1:
                string = strings[0]
            else:
                string = "({})".format(", ".join(strings))
            
            table[i//w][i%w] = string
        out.append(indent(concat_tabular_strings(table)))
    
    # Add padding bits
    if bits_remaining > 0:
        out.append("{} unused bit{}: {}".format(
            bits_remaining,
            "s" if bits_remaining != 1 else "",
            # Mask off only the bits actually used
            ellipsise(Bin(bits_remaining)(block_padding & ((1<<bits_remaining)-1))),
        ))
    
    return "\n".join(out)


class ComponentView(object):
    """
    A view for accessing the component transform values of a slice in a
    :py:class:`BaseSliceArray`.
    """
    
    def __init__(self, slice_array, component, sx, sy):
        """
        Parameters
        ==========
        slice_array : :py:class:`BaseSliceArray`
        component : "y", "c1" or "c2"
        sx, sy : int
        """
        self._slice_array = slice_array
        self._component = component
        self._sx = sx
        self._sy = sy
    
    @property
    def component(self):
        return self._component
    
    def __getitem__(self, key):
        """
        Access the subband data for this component. Indices should be either
        subband indices (a single integer) or a two-part index consisting of a
        level (int) and subband name (e.g. "HL") as accepted by
        :py:func:`SubbandArray.subband_to_index`.
        
        The following indexing styles are supported:
        * ``v[subband_index]``
        * ``v[level, subband_name]`` (e.g. ``v[2, "HL"]``)
        """
        if isinstance(key, tuple):
            level, subband = key
            key = SubbandArray.subband_to_index(
                level,
                subband,
                self._slice_array._dwt_depth,
                self._slice_array._dwt_depth_ho,
            )
        
        return ComponentSubbandView(
            self._slice_array,
            self._component,
            self._sx,
            self._sy,
            key,
        )
    
    def __len__(self):
        return self._slice_array._num_subbands
    
    def __iter__(self):
        """
        Iterate over :py:class:`ComponentSubbandView` views of the subbands for
        this component.
        """
        for subband_index in range(self._slice_array._num_subbands):
            yield self[subband_index]
    
    def items(self):
        """
        Iterator producing (level, subband_name, component_subband_view) tuples
        for each :py:class:`ComponentSubbandView` instance.
        """
        for i, transform_value in enumerate(self):
            level, subband = SubbandArray.index_to_subband(
                i,
                self._slice_array._dwt_depth,
                self._slice_array._dwt_depth_ho,
            )
            yield (level, subband, transform_value)
    
    def __repr__(self):
        return "<{} sx={} sy={} slice_index={}>".format(
            self.__class__.__name__,
            self._sx,
            self._sy,
            self._slice_index,
        )


class ComponentSubbandView(object):
    """
    A view for accessing the transform values of a particular subband and slice
    in a :py:class:`BaseSliceArray`.
    """
    
    def __init__(self, slice_array, component, sx, sy, subband_index):
        """
        Parameters
        ==========
        slice_array : :py:class:`BaseSliceArray`
        component : "y", "c1" or "c2"
        sx, sy : int
        subband_index : int
        """
        self._slice_array = slice_array
        self._component = component
        self._sx = sx
        self._sy = sy
        self._subband_index = subband_index
        
        if self._component == "y":
            self._data = self._slice_array._y_coeffs
            self._to_index = self._slice_array._to_luma_coeff_index
            self._subband_widths = self._slice_array._luma_subband_widths
            self._subband_heights = self._slice_array._luma_subband_heights
        elif self._component == "c1":
            self._data = self._slice_array._c1_coeffs
            self._to_index = self._slice_array._to_color_diff_coeff_index
            self._subband_widths = self._slice_array._color_diff_subband_widths
            self._subband_heights = self._slice_array._color_diff_subband_heights
        elif self._component == "c2":
            self._data = self._slice_array._c2_coeffs
            self._to_index = self._slice_array._to_color_diff_coeff_index
            self._subband_widths = self._slice_array._color_diff_subband_widths
            self._subband_heights = self._slice_array._color_diff_subband_heights
        else:
            raise ValueError("Invalid component.")
    
    @property
    def subband(self):
        return SubbandArray.index_to_subband(
            self._subband_index,
            self._slice_array._dwt_depth,
            self._slice_array._dwt_depth_ho,
        )
    
    @property
    def subband_index(self):
        return self._subband_index
    
    @property
    def bounds(self):
        """
        The (x1, y1, x2, y2) bounds (within its component) of this subband's
        coefficient data.
        """
        return slice_subband_bounds(
            self._sx, self._sy,
            self._subband_widths[self._subband_index],
            self._subband_heights[self._subband_index],
            self._slice_array._slices_x,
            self._slice_array._slices_y,
        )
    
    @property
    def dimensions(self):
        """The (width, height) of this slice's subband data."""
        x1, y1, x2, y2 = self.bounds
        return (x2 - x1, y2 - y1)
    
    def __len__(self):
        w, h = self.dimensions
        return w * h
    
    def __iter__(self):
        """Iterate over the individual transform values."""
        return iter(self[:])
    
    def _normalise_key(self, key):
        if isinstance(key, tuple):
            x, y = key
            return self._to_index(
                self._sx,
                self._sy,
                self._subband_index,
                x,
                y,
            )
        else:
            offset = self._to_index(self._sx, self._sy, self._subband_index)
            width, height = self.dimensions
            length = width * height
            
            if isinstance(key, slice):
                negative_step = key.step is not None and key.step < 0
                
                start = key.start
                if start is None:
                    start = -1 if negative_step else 0
                
                stop = key.stop
                if stop is None:
                    stop = -length-1 if negative_step else length
                
                # Handle -ve indices
                if start < 0:
                    start += length
                if stop < 0:
                    stop += length
                
                # Truncate the range
                start = max(0, min(length-1, start))
                stop = max(-1, min(length, stop))
                
                return slice(offset + start, offset + stop, key.step)
            else:
                if key > length:
                    raise IndexError("Coefficient index out of range.")
                return offset + key
            
    
    def __getitem__(self, key):
        """
        Index into the individual transform values within the subband.
        
        The following indexing styles are supported:
        * ``v[x, y]``
        * ``v[index]``
        * ``v[index_start:index_stop:index_step]``
        """
        key = self._normalise_key(key)
        return self._data[key]
    
    def __setitem__(self, key, value):
        key = self._normalise_key(key)
        self._data[key] = value
        self._slice_array._changed()
    
    def items(self):
        """
        Iterator producing (x, y, transform_value) tuples for individual
        transform values.
        """
        width = self.dimensions[0]
        for i, transform_value in enumerate(self):
            yield (i%width, i//width, transform_value)
    
    def __repr__(self):
        try:
            x1, y1, x2, y2 = self.bounds
        except:
            # In case of out-of-range parameters
            x1 = y1 = x2 = y2 = "?"
        
        return "<{} sx={} sy={} slice_index={} x=[{}, {}) y=[{}, {})>".format(
            self.__class__.__name__,
            self._sx,
            self._sy,
            self._slice_index,
            x1, y1,
            x2, y2,
        )


class LDSliceArray(BaseSliceArray):
    """
    An array of consecutive coded low-delay picture slices (13.5.3.1).
    """
    
    def __init__(self, *args, **kwargs):
        # Additional metrics specific to low-delay slices
        
        # Slice length in bytes as a fraction (12.4.5.2)
        self._slice_bytes_numerator = None
        self._slice_bytes_denominator = None
        
        
        # Additional data arrays for low-delay slices
        
        # The 'slice_y_length' value (13.5.3.1), one for each slice. A list
        # of integers, one per slice in raster-scan order.
        self._slice_y_length = []
        
        # The padding bits used to fill remaining space after each
        # luma/color-diff bounded block. A list of integers, one per slice in
        # raster-scan order.
        self._y_block_padding = []
        self._c_block_padding = []
        
        super(LDSliceArray, self).__init__(*args, **kwargs)
    
    def _update_metrics(self):
        super(LDSliceArray, self)._update_metrics()
        
        slice_parameters = self._transform_parameters["slice_parameters"]
        try:
            self._slice_bytes_numerator = max(0, slice_parameters["slice_bytes_numerator"].value)
        except:
            self._slice_bytes_numerator = 0
        
        try:
            self._slice_bytes_denominator = max(1, slice_parameters["slice_bytes_denominator"].value)
        except:
            self._slice_bytes_denominator = 1
    
    def _resize(self):
        super(LDSliceArray, self)._resize()
        
        resize_list(self._slice_y_length, self._slice_count)
        
        resize_list(self._y_block_padding, self._slice_count)
        resize_list(self._c_block_padding, self._slice_count)
    
    @staticmethod
    def slice_bytes(sx, sy, slice_bytes_numerator, slice_bytes_denominator, slices_x):
        """
        (13.5.3.2) Return the length of a low-delay picture slice.
    
        Produces lengths which vary from slice-to-slice to approximate the
        desired fractional length as closely as possible.
        """
        slice_number = (sy * slices_x) + sx
        bytes = (((slice_number + 1) * slice_bytes_numerator) //
                 slice_bytes_denominator)
        bytes -= ((slice_number * slice_bytes_numerator) //
                  slice_bytes_denominator)
        return bytes
    
    @property
    def length(self):
        return sum(
            8 * LDSliceArray.slice_bytes(
                sx, sy,
                self._slice_bytes_numerator, self._slice_bytes_denominator,
                self._slices_x
            )
            for slice_index, sx, sy in self._iter_slice_indices_and_coords()
        )
    
    def _get_view(self, sx, sy):
        return LDSliceView(self, sx, sy)
    
    def _io_fsm(self):
        """
        A token generator for :py:module:`_fsm_io` module functions defining
        the low-delay slice array syntax, mirroring ld_slice (13.5.3.1) fairly
        closely.
        """
        for slice_index, sx, sy in self._iter_slice_indices_and_coords():
            slice_bits_left = 8 * LDSliceArray.slice_bytes(
                sx, sy,
                self._slice_bytes_numerator, self._slice_bytes_denominator,
                self._slices_x)
            
            yield (TokenTypes.nbits, 7, "qindex")
            slice_bits_left -= 7
            
            length_bits = intlog2(slice_bits_left)
            slice_y_length = yield (TokenTypes.nbits, length_bits, "slice_y_length")
            slice_bits_left -= length_bits
            slice_y_length = min(slice_bits_left, slice_y_length)
            
            num_luma_coeffs, num_color_diff_coeffs = self._get_slice_num_component_coefficients(sx, sy)
            
            yield (TokenTypes.bounded_block_begin, slice_y_length, None)
            for _ in range(num_luma_coeffs):
                yield (TokenTypes.sint, None, "y_coeffs")
            yield (TokenTypes.bounded_block_end, None, "y_block_padding")
            
            slice_bits_left -= slice_y_length
            
            yield (TokenTypes.bounded_block_begin, slice_bits_left, None)
            for _ in range(num_color_diff_coeffs):
                yield (TokenTypes.sint, None, "c1_coeffs")
                yield (TokenTypes.sint, None, "c2_coeffs")
            yield (TokenTypes.bounded_block_end, None, "c_block_padding")
    
    def read(self, reader):
        self._offset = reader.tell()
        self._bits_past_eof = read_fsm(reader, self._io_fsm(), {
            "qindex": self._qindex,
            "slice_y_length": self._slice_y_length,
            "y_coeffs": self._y_coeffs,
            "c1_coeffs": self._c1_coeffs,
            "c2_coeffs": self._c2_coeffs,
            "y_block_padding": self._y_block_padding,
            "c_block_padding": self._c_block_padding,
        })
        
        self._changed()
    
    def write(self, writer):
        self._offset = writer.tell()
        self._bits_past_eof = write_fsm(writer, self._io_fsm(), {
            "qindex": self._qindex,
            "slice_y_length": self._slice_y_length,
            "y_coeffs": self._y_coeffs,
            "c1_coeffs": self._c1_coeffs,
            "c2_coeffs": self._c2_coeffs,
            "y_block_padding": self._y_block_padding,
            "c_block_padding": self._c_block_padding,
        })


class LDSliceView(BaseSliceView):
    """
    A view for accessing the values of a single low-delay slice in a
    :py:class:`LDSliceArray`.
    """
    
    @property
    def slice_y_length(self):
        return self._slice_array._slice_y_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @slice_y_length.setter
    def slice_y_length(self, value):
        self._slice_array._slice_y_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def length(self):
        """The total length of this slice in bits."""
        return 8 * LDSliceArray.slice_bytes(
            self._sx,
            self._sy,
            self._slice_array._slice_bytes_numerator,
            self._slice_array._slice_bytes_denominator,
            self._slice_array._slices_x
        )
    
    @property
    def header_length(self):
        """The total length of the qindex and slice_y_length fields."""
        return 7 + intlog2(self.length - 7)
    
    @property
    def true_slice_y_length(self):
        """
        The length of the luminance bounded block in this slice (in
        bits).
        
        May differ from :py:attr:`slice_y_length` if the specified length is
        (erroneously) larger than the slice.
        """
        max_slice_y_length = self.length - self.header_length
        return min(max_slice_y_length, self.slice_y_length)
    
    @property
    def slice_c_length(self):
        """
        The computed length of the color-difference bounded block in this slice
        (in bits).
        """
        return self.length - self.header_length - self.true_slice_y_length
    
    @property
    def y_block_padding(self):
        return self._slice_array._y_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @y_block_padding.setter
    def y_block_padding(self, value):
        self._slice_array._y_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def c_block_padding(self):
        return self._slice_array._c_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @c_block_padding.setter
    def c_block_padding(self, value):
        self._slice_array._c_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    def __str__(self):
        out = [
            "qindex: {}".format(self.qindex),
            "slice_y_length: {}".format(self.slice_y_length),
            "y_coeffs:",
            indent(component_views_str(
                self.true_slice_y_length,
                self.y_block_padding,
                self.y_coeffs,
            )),
            "c1_coeffs & c2_coeffs:",
            indent(component_views_str(
                self.slice_c_length,
                self.c_block_padding,
                self.c1_coeffs,
                self.c2_coeffs,
            )),
        ]
        
        return "ld_slice(sx={}, sy={}):\n{}".format(
            self._sx,
            self._sy,
            indent("\n".join(out)),
        )


class HQSliceArray(BaseSliceArray):
    """
    An array of consecutive coded high-quality picture slices (13.5.4).
    """
    
    def __init__(self, *args, **kwargs):
        # Additional metrics specific to high-quality slices
        
        # Slice sizing parameters (12.4.5.2)
        self._slice_prefix_bytes = None
        self._slice_size_scaler = None
        
        
        # Additional data arrays for high-quality slices
        
        # The slice prefix bytes (13.5.4). A list bytes strings, one per slice.
        self._prefix_bytes = []
        
        # The unscaled lengths for each picture component (13.5.4). A flat list
        # of integers, one per slice.
        self._slice_y_length = []
        self._slice_c1_length = []
        self._slice_c2_length = []
        
        # The padding bits used to fill remaining space after each
        # luma/color-diff bounded block. A list of integers, one per slice in
        # raster-scan order.
        self._y_block_padding = []
        self._c1_block_padding = []
        self._c2_block_padding = []
        
        super(HQSliceArray, self).__init__(*args, **kwargs)
    
    def _update_metrics(self):
        super(HQSliceArray, self)._update_metrics()
        
        slice_parameters = self._transform_parameters["slice_parameters"]
        
        try:
            self._slice_prefix_bytes = max(0, slice_parameters["slice_prefix_bytes"].value)
        except:
            self._slice_prefix_bytes = 0
        
        try:
            self._slice_size_scaler = max(0, slice_parameters["slice_size_scaler"].value)
        except:
            self._slice_size_scaler = 0
    
    def _resize(self):
        super(HQSliceArray, self)._resize()
        
        resize_list(self._prefix_bytes, self._slice_count, bytes)
        
        resize_list(self._slice_y_length, self._slice_count)
        resize_list(self._slice_c1_length, self._slice_count)
        resize_list(self._slice_c2_length, self._slice_count)
        
        resize_list(self._y_block_padding, self._slice_count)
        resize_list(self._c1_block_padding, self._slice_count)
        resize_list(self._c2_block_padding, self._slice_count)
    
    def _get_view(self, sx, sy):
        return HQSliceView(self, sx, sy)
    
    @property
    def length(self):
        return sum(
            # Prefix bytes
            (8 * self._slice_prefix_bytes) +
            # qindex
            8 +
            # Y-coeffs length field and coefficients
            8 +
            (8 * (self._slice_y_length[slice_index] * self._slice_size_scaler)) +
            # C1-coeffs length field and coefficients
            8 +
            (8 * (self._slice_c1_length[slice_index] * self._slice_size_scaler)) +
            # C2-coeffs length field and coefficients
            8 +
            (8 * (self._slice_c2_length[slice_index] * self._slice_size_scaler))
            for slice_index in range(self._slice_count)
        )
    
    def _io_fsm(self):
        """
        A token generator for :py:module:`_fsm_io` module functions defining
        the high-quality slice array syntax, mirroring hq_slice (13.5.4) fairly
        closely.
        """
        for slice_index, sx, sy in self._iter_slice_indices_and_coords():
            yield (TokenTypes.nbytes, self._slice_prefix_bytes, "prefix_bytes")
            
            yield (TokenTypes.nbits, 8, "qindex")
            
            num_luma_coeffs, num_color_diff_coeffs = self._get_slice_num_component_coefficients(sx, sy)
            
            # Read coefficients for each component
            for component, (length_target, coeffs_target, padding_target, num_coeffs) in enumerate([
                    ("slice_y_length", "y_coeffs", "y_block_padding", num_luma_coeffs),
                    ("slice_c1_length", "c1_coeffs", "c1_block_padding", num_color_diff_coeffs),
                    ("slice_c2_length", "c2_coeffs", "c2_block_padding", num_color_diff_coeffs)]):
                length = yield (TokenTypes.nbits, 8, length_target)
                length = length * 8 * self._slice_size_scaler
                
                # Read coefficients
                yield (TokenTypes.bounded_block_begin, length, None)
                for _ in range(num_coeffs):
                    yield (TokenTypes.sint, None, coeffs_target)
                yield (TokenTypes.bounded_block_end, None, padding_target)
    
    def read(self, reader):
        self._offset = reader.tell()
        self._bits_past_eof = read_fsm(reader, self._io_fsm(), {
            "prefix_bytes": self._prefix_bytes,
            "qindex": self._qindex,
            "slice_y_length": self._slice_y_length,
            "slice_c1_length": self._slice_c1_length,
            "slice_c2_length": self._slice_c2_length,
            "y_coeffs": self._y_coeffs,
            "c1_coeffs": self._c1_coeffs,
            "c2_coeffs": self._c2_coeffs,
            "y_block_padding": self._y_block_padding,
            "c1_block_padding": self._c1_block_padding,
            "c2_block_padding": self._c2_block_padding,
        })
        self._changed()
    
    def write(self, writer):
        self._offset = writer.tell()
        self._bits_past_eof = write_fsm(writer, self._io_fsm(), {
            "prefix_bytes": self._prefix_bytes,
            "qindex": self._qindex,
            "slice_y_length": self._slice_y_length,
            "slice_c1_length": self._slice_c1_length,
            "slice_c2_length": self._slice_c2_length,
            "y_coeffs": self._y_coeffs,
            "c1_coeffs": self._c1_coeffs,
            "c2_coeffs": self._c2_coeffs,
            "y_block_padding": self._y_block_padding,
            "c1_block_padding": self._c1_block_padding,
            "c2_block_padding": self._c2_block_padding,
        })


class HQSliceView(BaseSliceView):
    """
    A view for accessing the values of a single high-quality slice in a
    :py:class:`HQSliceArray`.
    """
    @property
    def prefix_bytes(self):
        return self._slice_array._prefix_bytes[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @prefix_bytes.setter
    def prefix_bytes(self, value):
        self._slice_array._prefix_bytes[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def slice_y_length(self):
        return self._slice_array._slice_y_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @slice_y_length.setter
    def slice_y_length(self, value):
        self._slice_array._slice_y_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def slice_c1_length(self):
        return self._slice_array._slice_c1_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @slice_c1_length.setter
    def slice_c1_length(self, value):
        self._slice_array._slice_c1_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def slice_c2_length(self):
        return self._slice_array._slice_c2_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @slice_c2_length.setter
    def slice_c2_length(self, value):
        self._slice_array._slice_c2_length[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def true_slice_y_length(self):
        """The calculated length of the luma block in bits."""
        return self.slice_y_length * self._slice_array._slice_size_scaler * 8
    
    @property
    def true_slice_c1_length(self):
        """The calculated length of color difference 1 block in bits."""
        return self.slice_c1_length * self._slice_array._slice_size_scaler * 8
    
    @property
    def true_slice_c2_length(self):
        """The calculated length of color difference 2 block in bits."""
        return self.slice_c2_length * self._slice_array._slice_size_scaler * 8
    
    @property
    def y_block_padding(self):
        return self._slice_array._y_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @y_block_padding.setter
    def y_block_padding(self, value):
        self._slice_array._y_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def c1_block_padding(self):
        return self._slice_array._c1_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @c1_block_padding.setter
    def c1_block_padding(self, value):
        self._slice_array._c1_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    @property
    def c2_block_padding(self):
        return self._slice_array._c2_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ]
    
    @c2_block_padding.setter
    def c2_block_padding(self, value):
        self._slice_array._c2_block_padding[
            self._slice_array._to_slice_index(self._sx, self._sy)
        ] = value
        self._slice_array._changed()
    
    def __str__(self):
        out = (
            [
                "prefix_bytes: {}".format(
                    " ".join(map(Hex(2), bytearray(self.prefix_bytes))))
            ]
            if self._slice_array._slice_prefix_bytes != 0 else
            []
        ) + [
            "qindex: {}".format(self.qindex),
            "slice_y_length: {}".format(self.slice_y_length),
            "y_coeffs:",
            indent(component_views_str(
                self.true_slice_y_length,
                self.y_block_padding,
                self.y_coeffs,
            )),
            "slice_c1_length: {}".format(self.slice_c1_length),
            "c1_coeffs:",
            indent(component_views_str(
                self.true_slice_c1_length,
                self.c1_block_padding,
                self.c1_coeffs,
            )),
            "slice_c2_length: {}".format(self.slice_c2_length),
            "c2_coeffs:",
            indent(component_views_str(
                self.true_slice_c2_length,
                self.c2_block_padding,
                self.c2_coeffs,
            )),
        ]
        
        return "hq_slice(sx={}, sy={}):\n{}".format(
            self._sx,
            self._sy,
            indent("\n".join(out)),
        )
